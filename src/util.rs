/// Traits and utilities for internal usage

///////////////////////////////////////////////////////////////////////////////
/// IsEmpty
///////////////////////////////////////////////////////////////////////////////

// TODO: Reuse from https://github.com/Stebalien/tool-rs?
pub(crate) trait IsEmpty {
    fn is_empty(&self) -> bool;
}

/// Trivial implementation of `IsEmpty` for the unit type `()`
impl IsEmpty for () {
    fn is_empty(&self) -> bool {
        true
    }
}

///////////////////////////////////////////////////////////////////////////////
/// Mergeable
///////////////////////////////////////////////////////////////////////////////

pub(crate) trait Mergeable {
    type Item;

    /// Create an empty instance with an initial or expected capacity
    fn empty(capacity: usize) -> Self;

    /// Merge with another instance
    fn merge(self, other: Self) -> Self;

    /// Merge with items generated by an iterator
    fn merge_from_iter<I>(self, reserve: usize, from_iter: I) -> Self
    where
        I: Iterator<Item = Self::Item>;
}

/// Trivial implementation of `Mergeable` for the unit type `()`
impl Mergeable for () {
    type Item = ();

    fn empty(_: usize) -> Self {}

    fn merge(self, _: Self) -> Self {}

    fn merge_from_iter<I>(self, _: usize, _: I) -> Self {}
}

///////////////////////////////////////////////////////////////////////////////
/// UnitResult
///////////////////////////////////////////////////////////////////////////////

/// A result with only an error and the unit type `()` on success
pub(crate) type UnitResult<E> = core::result::Result<(), E>;

///
impl<E> Mergeable for UnitResult<E>
where
    E: Mergeable + IsEmpty,
{
    type Item = E::Item;

    fn empty(_: usize) -> Self {
        Ok(())
    }

    fn merge(self, other: Self) -> Self {
        match (self, other) {
            (Ok(()), Ok(())) => Ok(()),
            (Ok(()), Err(err)) => Err(err),
            (Err(err), Ok(())) => Err(err),
            (Err(e1), Err(e2)) => Err(e1.merge(e2)),
        }
    }

    fn merge_from_iter<I>(self, reserve: usize, from_iter: I) -> Self
    where
        I: Iterator<Item = Self::Item>,
    {
        match self {
            Ok(()) => Self::empty(reserve).merge_from_iter(reserve, from_iter),
            Err(e) => Err(e.merge_from_iter(reserve, from_iter)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    impl IsEmpty for usize {
        fn is_empty(&self) -> bool {
            *self == 0
        }
    }

    impl Mergeable for usize {
        type Item = usize;

        fn empty(_: usize) -> Self {
            0
        }

        fn merge(self, other: Self) -> Self {
            self + other
        }

        fn merge_from_iter<I>(self, _: usize, from_iter: I) -> Self
        where
            I: Iterator<Item = Self::Item>,
        {
            from_iter.fold(self, |sum, item| sum + item)
        }
    }

    #[test]
    fn unit_is_empty() {
        assert!(().is_empty())
    }

    #[test]
    fn unit_mergeable() {
        assert_eq!((), <() as Mergeable>::empty(5));
        assert_eq!((), ().merge(()));
        assert_eq!((), ().merge_from_iter(3, core::iter::repeat(()).take(3)));
    }

    #[test]
    fn unit_result() {
        assert_eq!(Ok(()) as UnitResult<usize>, Ok(()).merge(Ok(())));
        assert_eq!(Err(1usize), Err(1).merge(Ok(())));
        assert_eq!(Err(2usize), Ok(()).merge(Err(2)));
        assert_eq!(Err(3usize), Err(1).merge(Err(2)));
    }
}
